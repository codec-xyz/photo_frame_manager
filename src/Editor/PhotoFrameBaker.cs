using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEngine;
using UnityEngine.UIElements.Experimental;
using UnityEngine.WSA;
using static codec.PhotoFrame.TextureBaker;
using static UnityEditor.PlayerSettings;

namespace codec.PhotoFrame {
	public static class PhotoFrameBaker {
		public static string AssureAutoSaveFolder() {
			string baseFolder = "Assets";
			string folder = "PhotoFramesAutoGenerated";
			string folderPath = $"{baseFolder}/{folder}";

			if(!AssetDatabase.IsValidFolder(folderPath)) AssetDatabase.CreateFolder(baseFolder, folder);
			return folderPath;
		}

		public static (TextureBaker.Input[] inputs, int[] indexes) PhotoFramesToInputs(PhotoFrame[] pfs, bool joinDuplicates) {
			var info = pfs.Select(pf => {
				pf.getAspectRatios(out float photoAspectRatio, out float frameAspectRatio, out _);
				pf.getCropUV(photoAspectRatio, frameAspectRatio, out Vector2 uvMin, out Vector2 uvMax);
				return (texture: pf.photo, point: pf.transform.position, uvMin, uvMax, size: pf.getFinalResolution(false, true), useSrc: pf.dontBakePhotoUseSource);
			}).ToArray();

			var inputs = new List<(TextureBaker.Input i, int count)>();
			var indexes = new int[info.Length];

			for(int a = 0; a < info.Length; a++) {
				if(info[a].useSrc) {
					indexes[a] = -1;
					continue;
				}

				bool original = true;
				if(joinDuplicates) {
					for(int i = 0; i < inputs.Count(); i++) {
						if(inputs[i].i.texture != info[a].texture) continue;

						Vector2Int size = info[a].size;
						Vector2 uvMax = info[a].uvMax, uvMin = info[a].uvMin;
						int addedBySelf = (int)(size.x * (uvMax.x - uvMin.x) * size.y * (uvMax.y - uvMin.y));

						size = inputs[i].i.size;
						uvMax = inputs[i].i.uvMax;
						uvMin = inputs[i].i.uvMin;
						int alreadyUsed = (int)(size.x * (uvMax.x - uvMin.x) * size.y * (uvMax.y - uvMin.y));

						size = new Vector2Int(Math.Max(inputs[i].i.size.x, info[a].size.x), Math.Max(inputs[i].i.size.y, info[a].size.y));
						uvMin = new Vector2(Math.Min(inputs[i].i.uvMin.x, info[a].uvMin.x), Math.Min(inputs[i].i.uvMin.y, info[a].uvMin.y));
						uvMax = new Vector2(Math.Max(inputs[i].i.uvMax.x, info[a].uvMax.x), Math.Max(inputs[i].i.uvMax.y, info[a].uvMax.y));
						int addedTogether = (int)(size.x * (uvMax.x - uvMin.x) * size.y * (uvMax.y - uvMin.y)) - alreadyUsed;

						if(addedTogether > addedBySelf) continue;

						indexes[a] = i;
						var input = inputs[i].i;
						input.point += info[a].point;
						input.uvMin = new Vector2(Math.Min(input.uvMin.x, info[a].uvMin.x), Math.Min(input.uvMin.y, info[a].uvMin.y));
						input.uvMax = new Vector2(Math.Max(input.uvMax.x, info[a].uvMax.x), Math.Max(input.uvMax.y, info[a].uvMax.y));
						input.size = new Vector2Int(Math.Max(input.size.x, info[a].size.x), Math.Max(input.size.y, info[a].size.y));
						inputs[i] = (i: input, count: inputs[i].count + 1);
						original = false;
						break;
					}
				}

				if(original) {
					indexes[a] = inputs.Count();
					inputs.Add((i: new TextureBaker.Input {
						texture = info[a].texture,
						point = info[a].point,
						sortGroup = 0,
						uvMin = info[a].uvMin,
						uvMax = info[a].uvMax,
						size = info[a].size,
					}, count: 1));
				}
			}

			TextureBaker.Input[] tBInputs = inputs.Select(input => {
				TextureBaker.Input tBInput = input.i;
				tBInput.point /= input.count;
				tBInput.size = new Vector2Int(
					(int)(tBInput.size.x * (tBInput.uvMax.x - tBInput.uvMin.x)),
					(int)(tBInput.size.y * (tBInput.uvMax.y - tBInput.uvMin.y))
				);
				return tBInput;
			}).ToArray();

			return (tBInputs, indexes);
		}

		public static void LimitPhotoSize(TextureBaker.Input[] inputs, int textureSize, int margin) {
			int sizeLimit = textureSize - margin * 2;
			for(int i = 0; i < inputs.Length; i++) {
				Vector2Int size = inputs[i].size;
				if(size.x > sizeLimit) size = size * sizeLimit / size.x;
				if(size.y > sizeLimit) size = size * sizeLimit / size.y;
				inputs[i].size = size;
			}
		}

		public static void MakeDummyTextures(string[] paths) {
			byte[] dummyTextureData = Utils.MakeTexture(1, 1, Color.white).EncodeToPNG();
			foreach(string path in paths) {
				File.WriteAllBytes(path, dummyTextureData);
				AssetDatabase.ImportAsset(path);
			}
		}

		public static (Vector2 uvMin, Vector2 uvMax) CalcFinalUv(Vector2 uvMin, Vector2 uvMax, Vector2 inputUvMin, Vector2 inputUvMax, Vector2 outputUvMin, Vector2 outputUvMax, bool rotate) {
			Vector2 subUvMin = new Vector2(
				Utils.Map(uvMin.x, inputUvMin.x, inputUvMax.x, 0, 1),
				Utils.Map(uvMin.y, inputUvMin.y, inputUvMax.y, 0, 1)
			);
			Vector2 subUvMax = new Vector2(
				Utils.Map(uvMax.x, inputUvMin.x, inputUvMax.x, 0, 1),
				Utils.Map(uvMax.y, inputUvMin.y, inputUvMax.y, 0, 1)
			);

			if(rotate) {
				(subUvMin, subUvMax) = (
					new Vector2(subUvMin.y, 1 - subUvMax.x),
					new Vector2(subUvMax.y, 1 - subUvMin.x)
				);
			}

			Vector2 newUvMin = new Vector2(
				Utils.Map(subUvMin.x, 0, 1, outputUvMin.x, outputUvMax.x),
				Utils.Map(subUvMin.y, 0, 1, outputUvMin.y, outputUvMax.y)
			);
			Vector2 newUvMax = new Vector2(
				Utils.Map(subUvMax.x, 0, 1, outputUvMin.x, outputUvMax.x),
				Utils.Map(subUvMax.y, 0, 1, outputUvMin.y, outputUvMax.y)
			);

			return (newUvMin, newUvMax);
		}

		public static void Progress_BakePackSort(string info, float progess) => EditorUtility.DisplayProgressBar("Photo Frame Bake", info, progess * 0.3f);
		public static void Progress_PreparingTextureFiles(int i, int total) => EditorUtility.DisplayProgressBar("Photo Frame Bake", $"Preparing texture files {i + 1}/{total}", 0.3f + 0.1f * (i / (float)total));
		public static void Progress_PreparingFrames(int i, int total) => EditorUtility.DisplayProgressBar("Photo Frame Bake", $"Preparing frames {i + 1}/{total}", 0.4f + 0.05f * (i / (float)total));
		public static void Progress_SavingTexutes(int i, int total) => EditorUtility.DisplayProgressBar("Photo Frame Bake", $"Saving textures {i + 1}/{total}", 0.45f + 0.3f * (i / (float)total));
		public static void Progress_SettingUpPhotoFrames(int i, int total) => EditorUtility.DisplayProgressBar("Photo Frame Bake", $"Setting up photo frames {i + 1}/{total}", 0.75f + 0.25f * (i / (float)total));

		public delegate void BakeProgressUpdate(string info, float progress);
		public static void Bake(PhotoFrame[] photoFrames, SceneSettings settings, bool isDebug) {
			if(photoFrames.Length == 0) return;
			(TextureBaker.Input[] photoFrameInput, int[] indexes) = PhotoFramesToInputs(photoFrames, settings.joinDuplicates);
			LimitPhotoSize(photoFrameInput, settings.textureSize, settings.margin);
			TextureBaker.isDebug = isDebug;
			TextureBaker.Output[] outputs = TextureBaker.Bake(photoFrameInput, settings.textureSize, settings.margin, settings.scaleMargin, Mathf.Pow(settings.textureFit * 50f, 2), settings.skylineMaxSpread, settings.overhangWeight, settings.neighborhoodWasteWeight, settings.topWasteWeight, settings.estimatedPackEfficiency, out Texture2D[] textures, Progress_BakePackSort);

			string folder = AssureAutoSaveFolder();
			string[] texturePaths = Enumerable.Range(0, textures.Length).Select(_ => $"{folder}/Photo-Texture-{System.Guid.NewGuid()}.png").ToArray();
			string[] meshPaths = Enumerable.Range(0, photoFrames.Length).Select(_ => $"{folder}/Photo-Mesh-{System.Guid.NewGuid()}.asset").ToArray();

			byte[] dummyTextureData = Utils.MakeTexture(1, 1, Color.white).EncodeToPNG();
			for(int i = 0; i < texturePaths.Length; i++) {
				Progress_PreparingTextureFiles(i, texturePaths.Length);
				File.WriteAllBytes(texturePaths[i], dummyTextureData);
				AssetDatabase.ImportAsset(texturePaths[i]);
			}

			FrameBaker frames = new FrameBaker();
			for(int i = 0; i < photoFrames.Length; i++) {
				Progress_PreparingFrames(i, photoFrames.Length);
				frames.add_possiblyGenerateAndSave(photoFrames[i], folder);
			}

			try {
				AssetDatabase.StartAssetEditing();

				if(settings.hasBake) settings.deleteBake(false);

				settings.hasBake = true;
				settings.textures = texturePaths.Select(path => AssetDatabase.LoadAssetAtPath<Texture2D>(path)).ToArray();

				List<PhotoFrame>[] photoFramesSave = new List<PhotoFrame>[textures.Length + 1].Select(_ => new List<PhotoFrame>()).ToArray();
				List<Mesh>[] meshesSave = new List<Mesh>[textures.Length + 1].Select(_ => new List<Mesh>()).ToArray();
				MaterialBaker materials = new MaterialBaker();

				for(int i = 0; i < textures.Length; i++) {
					Progress_SavingTexutes(i, textures.Length);
					UpdateTextureImportSettings(settings, texturePaths[i], textures[i].width);
					File.WriteAllBytes(texturePaths[i], textures[i].EncodeToPNG());
					UnityEngine.Object.DestroyImmediate(textures[i]);
				}

				for(int i = 0; i < photoFrames.Length; i++) {
					int textureIndex = indexes[i] != -1 ? outputs[indexes[i]].texture : -2;
					PhotoFrame pf = photoFrames[i];

					if(textureIndex == -1) {
						Debug.LogError($"Failed to bake PhotoFrame({pf.name})");
						continue;
					}

					Progress_SettingUpPhotoFrames(i, photoFrames.Length);

					Texture2D texture = textureIndex == -2 ? pf.photo : settings.textures[textureIndex];
					Material material = materials.get_orGenerateAndSave(pf.photoMaterial, texture, pf.photoMaterialTextureSlot, folder);

					pf.getAspectRatios(out float photoAspectRatio, out float frameAspectRatio, out _);
					pf.getCropUV(photoAspectRatio, frameAspectRatio, out Vector2 uvMin, out Vector2 uvMax);

					Vector2 newUvMin = uvMin, newUvMax = uvMax;
					bool uvRotate = false;

					if(indexes[i] != -1) {
						(newUvMin, newUvMax) = CalcFinalUv(uvMin, uvMax, photoFrameInput[indexes[i]].uvMin, photoFrameInput[indexes[i]].uvMax, outputs[indexes[i]].uvMin, outputs[indexes[i]].uvMax, outputs[indexes[i]].uvRotate);
						uvRotate = outputs[indexes[i]].uvRotate;
					}

					Mesh mesh = pf.setBakedData(folder, material, newUvMin, newUvMax, uvRotate, (type, index, ratio, size) => frames.get(type, index, ratio, size));
					AssetDatabase.CreateAsset(mesh, meshPaths[i]);

					photoFramesSave[textureIndex == -2 ? textures.Length : textureIndex].Add(pf);
					meshesSave[textureIndex == -2 ? textures.Length : textureIndex].Add(mesh);
				}

				settings.pfCounts = photoFramesSave.Select(a => a.Count).ToArray();
				settings.photoFrames = photoFramesSave.SelectMany(a => a).ToArray();
				settings.meshes = meshesSave.SelectMany(a => a).ToArray();
				settings.materials = materials.getGeneratedMaterials();
				settings.frameMeshes = frames.getGeneratedMeshes();
				settings.framePrefabs = frames.getGeneratedPrefabs();
			}
			finally {
				//IDK unity 2022 needs two or asset import progress bar does not go away
				EditorUtility.ClearProgressBar();
				EditorUtility.ClearProgressBar();
				AssetDatabase.StopAssetEditing();
			}
		}

		public static void UpdateTextureImportSettings(SceneSettings settings, string path, int size = -1) {
			TextureImporter importer = (TextureImporter)TextureImporter.GetAtPath(path);
			importer.mipmapEnabled = true;
			importer.streamingMipmaps = true;
			if(size != -1) importer.maxTextureSize = size;
			else importer.maxTextureSize = Utils.GetTextureSourceSize(importer).x;
			importer.filterMode = FilterMode.Point;


			importer.mipmapEnabled = settings.tex_generateMipmaps;
			importer.streamingMipmaps = settings.tex_generateMipmaps && settings.tex_mipmapStreaming;
			importer.streamingMipmapsPriority = settings.tex_mipmapPriority;
			importer.mipMapsPreserveCoverage = settings.tex_preserveCoverage;
			importer.mipmapFilter = settings.tex_mipmapFiltering;
			importer.filterMode = settings.tex_filterMode;
			importer.anisoLevel = settings.tex_anisoLevel;
			importer.textureCompression = settings.tex_textureCompression;
			importer.crunchedCompression = settings.tex_crunchedCompression;
			importer.compressionQuality = settings.tex_crunchedcompressionQuality;

			EditorUtility.SetDirty(importer);
			importer.SaveAndReimport();
		}
	}

	public class MaterialBaker {
		public Dictionary<(Material material, Texture2D texture, string textureSlot), Material> materials = new Dictionary<(Material material, Texture2D texture, string textureSlot), Material>();

		public Material get_orGenerateAndSave(Material srcMaterial, Texture2D texture, string textureSlot, string folder) {
			bool found = materials.TryGetValue((srcMaterial, texture, textureSlot), out Material material);
			if(!found) {
				material = new Material(srcMaterial);
				string[] validSlots = material.GetTexturePropertyNames();
				foreach(string slot in textureSlot.Split(',').Select(slot => slot.Trim())) {
					if(slot == "" || !validSlots.Contains(slot)) continue;
					material.SetTexture(slot, texture);
				}
				AssetDatabase.CreateAsset(material, $"{folder}/Photo-Material-{System.Guid.NewGuid()}.mat");
				materials.Add((srcMaterial, texture, textureSlot), material);
			}
			return material;
		}

		public Material[] getGeneratedMaterials() {
			return materials.Values.ToArray();
		}
	}

	public class FrameBaker {
		public struct TypeInfo {
			public PhotoFrameType type;
			public int index;
			public float ratio;

			public GameObject prefab;
			public bool isGenerated;
		}
		public List<TypeInfo> frames = new List<TypeInfo>();

		public void add_possiblyGenerateAndSave(PhotoFrame pf, string folder) {
			if(pf.frameType == null) return;

			pf.getAspectRatios(out float photoAspectRatio, out float frameAspectRatio, out int frameIndex);
			pf.getCropUV(photoAspectRatio, frameAspectRatio, out _, out _);
			var size = pf.getPhotoWorldSize(frameAspectRatio, frameIndex, out Vector2 frameScale);

			TypeInfo sameInfo = frames.Find(info => info.type == pf.frameType && info.index == frameIndex && info.ratio == frameAspectRatio);
			if(sameInfo.type != null) return;

			GameObject prefab = pf.frameType.getOrGenerateFrame(frameIndex, frameAspectRatio, out bool isGenerated, size);
			if(isGenerated) {
				AssetDatabase.CreateAsset(prefab.GetComponent<MeshFilter>().sharedMesh, $"{folder}/Photo-FrameMesh-{System.Guid.NewGuid()}.asset");
				GameObject prefabFile = PrefabUtility.SaveAsPrefabAsset(prefab, $"{folder}/Photo-FramePrefab-{System.Guid.NewGuid()}.prefab");
				GameObject.DestroyImmediate(prefab);
				prefab = prefabFile;
			}
			sameInfo = new TypeInfo { type = pf.frameType, index = frameIndex, ratio = frameAspectRatio, prefab = prefab, isGenerated = isGenerated };
			frames.Add(sameInfo);
		}

		public GameObject get(PhotoFrameType type, int index, float ratio, Vector2 size) {
			if(type == null) return null;
			var sameInfo = frames.Find(info => info.type == type && info.index == index && info.ratio == ratio);
			return sameInfo.prefab;
		}

		public Mesh[] getGeneratedMeshes() {
			return frames.Where(a => a.isGenerated).Select(a => a.prefab.GetComponent<MeshFilter>().sharedMesh).ToArray();
		}

		public GameObject[] getGeneratedPrefabs() {
			return frames.Where(a => a.isGenerated).Select(a => a.prefab).ToArray();
		}
	}
}